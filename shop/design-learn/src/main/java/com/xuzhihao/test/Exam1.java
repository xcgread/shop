package com.xuzhihao.test;
/**
 * 关于操作数栈与自增自减的面试题
 * @author Administrator
 *
 */
//考点：
// 赋值= 最后计算
// 从左到右依次压入操作数栈
// 实际计算按照运算符优先级
// 自增 自减直接操作局部变量表的值 不经过操作数栈
// 最后赋值之前的结果 存储在操作数栈中
// JVM虚拟机规范相关指令
public class Exam1 {

	public static void main(String[] args) {
		int i = 1;
		i = i++;
		int j = i++;
		int k = i + ++i * i++;
		/**
		 * 在i = i ++ 的时候 会想把i压入操作数栈 ，压栈的解析 从来都是从左往右的 所以 1 会被压入操作数栈 ， 然后继续往右解析 i 自增1 此时 i
		 * = 2 ,但是自增自减都是直接修改变量的值 而不经过操作数栈的，所以操作数栈里的值还是等于 1， 最后进行赋值操作 i = 1,所以i
		 * 又被操作数栈里的1覆盖了 所以 i还是等于1 。
		 */
		System.out.println(i);
		/**
		 * int j = i++ 其实与 i = i++ 情况一致 ，第一步 i = 1这个值进入操作数栈 ，随后在向右走 i自增 此时 i = 2 ,随后
		 * 操作数栈里的 1 再赋值给了 j 所以 j = 1。 于是到这一步： i = 2 ; j = 1;
		 */
		System.out.println(j);
		/**
		 * 还是从左往右解析操作数栈
		 * i = 2 , 2这个值先进入操作数栈 ，随后i自增 i变成了3 随后 3又进入了操作数栈 ，最后又是i++ 因为先遇到i所以此时 i =3
		 * 又进入操作数栈 后面 i 再自增 i 变成了4，
		 * 
		 * 但并不影响操作数栈的值 所以 最终的运算为 k = 2 + 3 * 3 =11
		 */
		System.out.println(k);

	}
}
